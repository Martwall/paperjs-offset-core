{"version":3,"file":"paperjs-offset-core.esm.js","sources":["../src/offset_core.ts","../src/index.ts"],"sourcesContent":["import type paper from 'paper/dist/paper-core';\n\nexport type StrokeJoinType = 'miter' | 'bevel' | 'round';\nexport type StrokeCapType = 'round' | 'butt';\nexport type PathType = paper.Path | paper.CompoundPath;\n\ntype HandleType = 'handleIn' | 'handleOut';\n\n/**\n * Offset the start/terminal segment of a bezier curve\n * @param segment segment to offset\n * @param curve curve to offset\n * @param handleNormal the normal of the the line formed of two handles\n * @param offset offset value\n */\nfunction offsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number, paperScope: paper.PaperScope) {\n  const isFirst = segment.curve === curve;\n  // get offset vector\n  const offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);\n  // get offset point\n  const point = segment.point.add(offsetVector);\n  const newSegment = new paperScope.Segment(point);\n  // handleOut for start segment & handleIn for terminal segment\n  const handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType;\n  newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2));\n  return newSegment;\n}\n\n/**\n * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\n * @param curve curve to offset\n * @param offset offset value\n */\nfunction adaptiveOffsetCurve(curve: paper.Curve, offset: number, paperScope: paper.PaperScope): paper.Segment[] {\n  const hNormal = (new paperScope.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paperScope.Point(0, 0),\n    new paperScope.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);\n  const segment1 = offsetSegment(curve.segment1, curve, hNormal, offset, paperScope);\n  const segment2 = offsetSegment(curve.segment2, curve, hNormal, offset, paperScope);\n  // divide && re-offset\n  const offsetCurve = new paperScope.Curve(segment1, segment2);\n  // if the offset curve is not self intersected, divide it\n  if (offsetCurve.getIntersections(offsetCurve).length === 0) {\n    const threshold = Math.min(Math.abs(offset) / 10, 1);\n    const midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));\n    if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\n      const subCurve = curve.divideAtTime(0.5);\n      if (subCurve != null) {\n        return [...adaptiveOffsetCurve(curve, offset, paperScope), ...adaptiveOffsetCurve(subCurve, offset, paperScope)];\n      }\n    }\n  }\n  return [segment1, segment2];\n}\n\n/**\n * Create a round join segment between two adjacent segments.\n */\nfunction makeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number, paperScope: paper.PaperScope) {\n  const through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))\n    .normalize(Math.abs(radius)).add(originPoint);\n  const arc = new paperScope.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false });\n  segment1.handleOut = arc.firstSegment.handleOut;\n  segment2.handleIn = arc.lastSegment.handleIn;\n  return arc.segments.length === 3 ? arc.segments[1] : null;\n}\n\nfunction det(p1: paper.Point, p2: paper.Point) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\n/**\n * Get the intersection point of point based lines\n */\nfunction getPointLineIntersections(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point, paperScope: paper.PaperScope) {\n  const l1 = p1.subtract(p2);\n  const l2 = p3.subtract(p4);\n  const dl1 = det(p1, p2);\n  const dl2 = det(p3, p4);\n  return new paperScope.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));\n}\n\n/**\n * Connect two adjacent bezier curve, each curve is represented by two segments,\n * create different types of joins or simply removal redundant segment.\n */\nfunction connectAdjacentBezier(segments1: paper.Segment[], segments2: paper.Segment[], origin: paper.Segment,\njoinType: StrokeJoinType, offset: number, limit: number, paperScope: paper.PaperScope) {\n  const curve1 = new paperScope.Curve(segments1[0], segments1[1]);\n  const curve2 = new paperScope.Curve(segments2[0], segments2[1]);\n  const intersection = curve1.getIntersections(curve2);\n  const distance = segments1[1].point.getDistance(segments2[0].point);\n  if (origin.isSmooth()) {\n    segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!);\n    segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!);\n    segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);\n    segments1.pop();\n  } else {\n    if (intersection.length === 0) {\n      if (distance > Math.abs(offset) * 0.1) {\n        // connect\n        switch (joinType) {\n          case 'miter':\n            const join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)),\n              curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)), paperScope);\n            // prevent sharp angle\n            const joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));\n            if (joinOffset < Math.abs(offset) * limit) {\n              segments1.push(new paperScope.Segment(join));\n            }\n            break;\n          case 'round':\n            const mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset, paperScope);\n            if (mid) {\n              segments1.push(mid);\n            }\n            break;\n          default: break;\n        }\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    } else {\n      const second1 = curve1.divideAt(intersection[0]);\n      if (second1) {\n        const join = second1.segment1;\n        const second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);\n        join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;\n        segments1.pop();\n        segments2[0] = join;\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    }\n  }\n}\n\n/**\n * Connect all the segments together.\n */\nfunction connectBeziers(rawSegments: paper.Segment[][], join: StrokeJoinType, source: paper.Path, offset: number,\n  limit: number, paperScope: paper.PaperScope) {\n  const originSegments = source.segments;\n  const first = rawSegments[0].slice();\n  for (let i = 0; i < rawSegments.length - 1; ++i) {\n    connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit, paperScope);\n  }\n  if (source.closed) {\n    connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit, paperScope);\n    rawSegments[0][0] = first[0];\n  }\n  return rawSegments;\n}\n\nfunction reduceSingleChildCompoundPath(path: PathType) {\n  if (path.children.length === 1) {\n    path = path.children[0] as paper.Path;\n    path.remove(); // remove from parent, this is critical, or the style attributes will be ignored\n  }\n  return path;\n}\n\n/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\nfunction normalize(path: PathType, areaThreshold = 0.01, paperScope: paper.PaperScope) {\n  if (path.closed) {\n    const ignoreArea = Math.abs(path.area * areaThreshold);\n    if (!path.clockwise) {\n      path.reverse();\n    }\n    path = path.unite(path, { insert: false }) as PathType;\n    if (path instanceof paperScope.CompoundPath) {\n      path.children.filter((c) => Math.abs((c as PathType).area) < ignoreArea).forEach((c) => c.remove());\n      if (path.children.length === 1) {\n        return reduceSingleChildCompoundPath(path);\n      }\n    }\n  }\n  return path;\n}\n\nfunction isSameDirection(partialPath: paper.Path, fullPath: PathType) {\n  const offset1 = partialPath.segments[0].location.offset;\n  const offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;\n  const sampleOffset = (offset1 + offset2) / 3;\n  const originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;\n  const originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;\n  return originOffset1 < originOffset2;\n}\n\n/** Remove self intersection when offset is negative by point direction dectection. */\nfunction removeIntersection(path: PathType, paperScope: paper.PaperScope) {\n  if (path.closed) {\n    const newPath = path.unite(path, { insert: false }) as PathType;\n    if (newPath instanceof paperScope.CompoundPath) {\n      (newPath.children as paper.Path[]).filter((c) => {\n        if (c.segments.length > 1) {\n          return !isSameDirection(c, path);\n        } else {\n          return true;\n        }\n      }).forEach((c) => c.remove());\n      return reduceSingleChildCompoundPath(newPath);\n    }\n  }\n  return path;\n}\n\nfunction getSegments(path: PathType, paperScope: paper.PaperScope) {\n  if (path instanceof paperScope.CompoundPath) {\n    return path.children.map((c) => (c as paper.Path).segments).flat();\n  } else {\n    return (path as paper.Path).segments;\n  }\n}\n\n/**\n * Remove impossible segments in negative offset condition.\n */\nfunction removeOutsiders(newPath: PathType, path: PathType, paperScope: paper.PaperScope) {\n  const segments = getSegments(newPath, paperScope).slice();\n  segments.forEach((segment) => {\n    if (!path.contains(segment.point)) {\n      segment.remove();\n    }\n  });\n}\n\nfunction preparePath(path: paper.Path, offset: number): [paper.Path, number] {\n  const source = path.clone({ insert: false }) as paper.Path;\n  source.reduce({});\n  if (!path.clockwise) {\n    source.reverse();\n    offset = -offset;\n  }\n  return [source, offset];\n}\n\nfunction offsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number, paperScope: paper.PaperScope): PathType {\n  let source: paper.Path;\n  [source, offset] = preparePath(path, offset);\n  const curves = source.curves.slice();\n  const offsetCurves = curves.map((curve) => adaptiveOffsetCurve(curve, offset, paperScope)).flat();\n  const raws: paper.Segment[][] = [];\n  for (let i = 0; i < offsetCurves.length; i += 2) {\n    raws.push(offsetCurves.slice(i, i + 2));\n  }\n  const segments = connectBeziers(raws, join, source, offset, limit, paperScope).flat();\n  const newPath = removeIntersection(new paperScope.Path({ segments, insert: false, closed: path.closed }), paperScope);\n  newPath.reduce({});\n  if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\n    removeOutsiders(newPath, path, paperScope);\n  }\n  // recovery path\n  if (source.clockwise !== path.clockwise) {\n    newPath.reverse();\n  }\n  return normalize(newPath, 0.01, paperScope);\n}\n\nfunction makeRoundCap(from: paper.Segment, to: paper.Segment, offset: number, paperScope: paper.PaperScope) {\n  const origin = from.point.add(to.point).divide(2);\n  const normal = to.point.subtract(from.point).rotate(-90, new paperScope.Point(0, 0)).normalize(offset);\n  const through = origin.add(normal);\n  const arc = new paperScope.Path.Arc({ from: from.point, to: to.point, through, insert: false });\n  return arc.segments;\n}\n\nfunction connectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType, paperScope: paper.PaperScope): paper.Path {\n  if (outer instanceof paperScope.CompoundPath) {\n    let cs = outer.children.map((c) => ({ c, a: Math.abs((c as paper.Path).area) }));\n    cs = cs.sort((c1, c2) => c2.a - c1.a);\n    outer = cs[0].c as paper.Path;\n  }\n  const oSegments = (outer as paper.Path).segments.slice();\n  const iSegments = inner.segments.slice();\n  switch (cap) {\n    case 'round':\n      const heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset, paperScope);\n      const tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset, paperScope);\n      const result = new paperScope.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false });\n      result.reduce({});\n      return result;\n    default: return new paperScope.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false });\n  }\n}\n\nfunction offsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number, paperScope: paper.PaperScope): PathType {\n  offset = path.clockwise ? offset : -offset;\n  const positiveOffset = offsetSimpleShape(path, offset, join, limit, paperScope);\n  const negativeOffset = offsetSimpleShape(path, -offset, join, limit, paperScope);\n  if (path.closed) {\n    return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType;\n  } else {\n    let inner = negativeOffset;\n    let holes = new Array<paper.Path>();\n    if (negativeOffset instanceof paperScope.CompoundPath) {\n      holes = negativeOffset.children.filter((c) => (c as paper.Path).closed) as paper.Path[];\n      holes.forEach((h) => h.remove());\n      inner = negativeOffset.children[0] as paper.Path;\n    }\n    inner.reverse();\n    let final = connectSide(positiveOffset, inner as paper.Path, offset, cap, paperScope) as PathType;\n    if (holes.length > 0) {\n      for (const hole of holes) {\n        final = final.subtract(hole, { insert: false }) as PathType;\n      }\n    }\n    return final;\n  }\n}\n\nfunction getNonSelfItersectionPath(path: PathType) {\n  if (path.closed) {\n    return path.unite(path, { insert: false }) as PathType;\n  }\n  return path;\n}\n\nexport function offsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number, paperScope: paper.PaperScope): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paperScope.Path) {\n    result = offsetSimpleShape(nonSIPath, offset, join, limit, paperScope);\n  } else {\n    const offsetParts = (nonSIPath.children as paper.Path[]).map((c) => {\n      if (c.segments.length > 1) {\n        if (!isSameDirection(c, path)) {\n          c.reverse();\n        }\n        let offseted = offsetSimpleShape(c, offset, join, limit, paperScope);\n        offseted = normalize(offseted, 0.01, paperScope);\n        if (offseted.clockwise !== c.clockwise) {\n          offseted.reverse();\n        }\n        if (offseted instanceof paperScope.CompoundPath) {\n          offseted.applyMatrix = true;\n          return offseted.children;\n        } else {\n          return offseted;\n        }\n      } else {\n        return null;\n      }\n    });\n    const children = offsetParts.flat().filter((c) => !!c) as paper.Item[];\n    result = new paperScope.CompoundPath({ children, insert: false });\n  }\n  result.copyAttributes(nonSIPath, false);\n  result.remove();\n  return result;\n}\n\nexport function offsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number, paperScope: paper.PaperScope): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paperScope.Path) {\n    result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit, paperScope);\n  } else {\n    const children = (nonSIPath.children as paper.Path[]).flatMap((c) => {\n      return offsetSimpleStroke(c, offset, join, cap, limit, paperScope);\n    });\n    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType);\n  }\n  result.strokeWidth = 0;\n  result.fillColor = nonSIPath.strokeColor;\n  result.shadowBlur = nonSIPath.shadowBlur;\n  result.shadowColor = nonSIPath.shadowColor;\n  result.shadowOffset = nonSIPath.shadowOffset;\n  return result;\n}\n","import type paper from 'paper/dist/paper-core';\nimport { StrokeJoinType, PathType, StrokeCapType, offsetPath, offsetStroke } from './offset_core';\n\nexport interface OffsetOptions {\n  join?: StrokeJoinType;\n  cap?: StrokeCapType;\n  limit?: number;\n  insert?: boolean;\n  scope: paper.PaperScope;\n}\n\nexport class PaperOffset {\n  public static offset(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    if (!options || !options.scope) {\n      throw new Error('Options need to be defined with a scope property referencing a Paperscope.');\n    }\n\n    const paperScope = options.scope;\n    const newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10, paperScope);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paperScope.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n\n  public static offsetStroke(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    if (!options || !options.scope) {\n      throw new Error('Options need to be defined with a scope property referencing a Paperscope.');\n    }\n\n    const paperScope = options.scope;\n    const newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10, paperScope);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paperScope.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n}\n"],"names":[],"mappings":"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"}