function e(e,t,n,o,i){const s=e.curve===t,r=t.getNormalAtTime(s?0:1).multiply(o),c=e.point.add(r),a=new i.Segment(c),l=s?"handleOut":"handleIn";return a[l]=e[l].add(n.subtract(r).divide(2)),a}function t(n,o,i){const s=new i.Curve(n.segment1.handleOut.add(n.segment1.point),new i.Point(0,0),new i.Point(0,0),n.segment2.handleIn.add(n.segment2.point)).getNormalAtTime(.5).multiply(o),r=e(n.segment1,n,s,o,i),c=e(n.segment2,n,s,o,i),a=new i.Curve(r,c);if(0===a.getIntersections(a).length){const e=Math.min(Math.abs(o)/10,1),s=a.getPointAtTime(.5).getDistance(n.getPointAtTime(.5));if(Math.abs(s-Math.abs(o))>e){const e=n.divideAtTime(.5);if(null!=e)return[...t(n,o,i),...t(e,o,i)]}}return[r,c]}function n(e,t){return e.x*t.y-e.y*t.x}function o(e,t,o,i,s,r,c){const a=new c.Curve(e[0],e[1]),l=new c.Curve(t[0],t[1]),d=a.getIntersections(l),u=e[1].point.getDistance(t[0].point);if(o.isSmooth())t[0].handleOut=t[0].handleOut.project(o.handleOut),t[0].handleIn=e[1].handleIn.project(o.handleIn),t[0].point=e[1].point.add(t[0].point).divide(2),e.pop();else if(0===d.length)if(u>.1*Math.abs(s))switch(i){case"miter":const i=function(e,t,o,i,s){const r=e.subtract(t),c=o.subtract(i),a=n(e,t),l=n(o,i);return new s.Point(a*c.x-r.x*l,a*c.y-r.y*l).divide(n(r,c))}(a.point2,a.point2.add(a.getTangentAtTime(1)),l.point1,l.point1.add(l.getTangentAtTime(0)),c);Math.max(i.getDistance(a.point2),i.getDistance(l.point1))<Math.abs(s)*r&&e.push(new c.Segment(i));break;case"round":const d=function(e,t,n,o,i){const s=e.point.subtract(n).add(t.point.subtract(n)).normalize(Math.abs(o)).add(n),r=new i.Path.Arc({from:e.point,to:t.point,through:s,insert:!1});return e.handleOut=r.firstSegment.handleOut,t.handleIn=r.lastSegment.handleIn,3===r.segments.length?r.segments[1]:null}(e[1],t[0],o.point,s,c);d&&e.push(d)}else t[0].handleIn=e[1].handleIn,e.pop();else{const n=a.divideAt(d[0]);if(n){const o=n.segment1,i=l.divideAt(l.getIntersections(a)[0]);o.handleOut=i?i.segment1.handleOut:t[0].handleOut,e.pop(),t[0]=o}else t[0].handleIn=e[1].handleIn,e.pop()}}function i(e){return 1===e.children.length&&(e=e.children[0]).remove(),e}function s(e,t=.01,n){if(e.closed){const o=Math.abs(e.area*t);if(e.clockwise||e.reverse(),(e=e.unite(e,{insert:!1}))instanceof n.CompoundPath&&(e.children.filter((e=>Math.abs(e.area)<o)).forEach((e=>e.remove())),1===e.children.length))return i(e)}return e}function r(e,t){const n=(e.segments[0].location.offset+e.segments[Math.max(1,Math.floor(e.segments.length/2))].location.offset)/3;return t.getNearestLocation(e.getPointAt(n)).offset<t.getNearestLocation(e.getPointAt(2*n)).offset}function c(e,n,c,a,l){let d;[d,n]=function(e,t){const n=e.clone({insert:!1});return n.reduce({}),e.clockwise||(n.reverse(),t=-t),[n,t]}(e,n);const u=d.curves.slice().map((e=>t(e,n,l))).flat(),h=[];for(let e=0;e<u.length;e+=2)h.push(u.slice(e,e+2));const f=function(e,t,n,i,s,r){const c=n.segments,a=e[0].slice();for(let n=0;n<e.length-1;++n)o(e[n],e[n+1],c[n+1],t,i,s,r);return n.closed&&(o(e[e.length-1],a,c[0],t,i,s,r),e[0][0]=a[0]),e}(h,c,d,n,a,l).flat(),p=function(e,t){if(e.closed){const n=e.unite(e,{insert:!1});if(n instanceof t.CompoundPath)return n.children.filter((t=>!(t.segments.length>1&&r(t,e)))).forEach((e=>e.remove())),i(n)}return e}(new l.Path({segments:f,insert:!1,closed:e.closed}),l);return p.reduce({}),d.closed&&(d.clockwise&&n<0||!d.clockwise&&n>0)&&function(e,t,n){const o=function(e,t){return e instanceof t.CompoundPath?e.children.map((e=>e.segments)).flat():e.segments}(e,n).slice();o.forEach((e=>{t.contains(e.point)||e.remove()}))}(p,e,l),d.clockwise!==e.clockwise&&p.reverse(),s(p,.01,l)}function a(e,t,n,o){const i=e.point.add(t.point).divide(2),s=t.point.subtract(e.point).rotate(-90,new o.Point(0,0)).normalize(n),r=i.add(s);return new o.Path.Arc({from:e.point,to:t.point,through:r,insert:!1}).segments}function l(e,t,n,o,i,s){const r=c(e,t=e.clockwise?t:-t,n,i,s),l=c(e,-t,n,i,s);if(e.closed)return r.subtract(l,{insert:!1});{let e=l,n=new Array;l instanceof s.CompoundPath&&(n=l.children.filter((e=>e.closed)),n.forEach((e=>e.remove())),e=l.children[0]),e.reverse();let i=function(e,t,n,o,i){if(e instanceof i.CompoundPath){let t=e.children.map((e=>({c:e,a:Math.abs(e.area)})));t=t.sort(((e,t)=>t.a-e.a)),e=t[0].c}const s=e.segments.slice(),r=t.segments.slice();if("round"===o){const e=a(r[r.length-1],s[0],n,i),t=a(s[s.length-1],r[0],n,i),o=new i.Path({segments:[...e,...s,...t,...r],closed:!0,insert:!1});return o.reduce({}),o}return new i.Path({segments:[...s,...r],closed:!0,insert:!1})}(r,e,t,o,s);if(n.length>0)for(const e of n)i=i.subtract(e,{insert:!1});return i}}function d(e){return e.closed?e.unite(e,{insert:!1}):e}class u{static offset(e,t,n){if(!n||!n.scope)throw new Error("Options need to be defined with a scope property referencing a Paperscope.");const o=n.scope,i=function(e,t,n,o,i){const a=d(e);let l=a;if(a instanceof i.Path)l=c(a,t,n,o,i);else{const d=a.children.map((a=>{if(a.segments.length>1){r(a,e)||a.reverse();let l=c(a,t,n,o,i);return l=s(l,.01,i),l.clockwise!==a.clockwise&&l.reverse(),l instanceof i.CompoundPath?(l.applyMatrix=!0,l.children):l}return null})).flat().filter((e=>!!e));l=new i.CompoundPath({children:d,insert:!1})}return l.copyAttributes(a,!1),l.remove(),l}(e,t,n.join||"miter",n.limit||10,o);return void 0===n.insert&&(n.insert=!0),n.insert&&(e.parent||o.project.activeLayer).addChild(i),i}static offsetStroke(e,t,n){if(!n||!n.scope)throw new Error("Options need to be defined with a scope property referencing a Paperscope.");const o=n.scope,i=function(e,t,n,o,i,s){const r=d(e);let c=r;c=r instanceof s.Path?l(r,t,n,o,i,s):r.children.flatMap((e=>l(e,t,n,o,i,s))).reduce(((e,t)=>e.unite(t,{insert:!1})));return c.strokeWidth=0,c.fillColor=r.strokeColor,c.shadowBlur=r.shadowBlur,c.shadowColor=r.shadowColor,c.shadowOffset=r.shadowOffset,c}(e,t,n.join||"miter",n.cap||"butt",n.limit||10,o);return void 0===n.insert&&(n.insert=!0),n.insert&&(e.parent||o.project.activeLayer).addChild(i),i}}export{u as PaperOffset};
